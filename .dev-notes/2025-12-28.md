# SSH-Hop v2.0 Roadmap

## Background

This document outlines improvements to the ssh-hop library based on analysis of a real-world use case: [](../examples/-migration/).

### Current Use Case ()
- **One-shot automation scripts**: Connect → Execute kubectl commands → Disconnect
- **Two-hop architecture**: Local → Pomerium → Jump Server → Remote K8s Host
- **Pain points**: Requires wrapper class, manual state tracking, repeated credentials

### Future Use Case (Long-lived Service)
- **Backend service**: Persistent connections, handle N requests without re-hopping
- **Requirements**: Auto-reconnection, health monitoring, connection pooling

---

## Problem Statements

### Problem 1: No Pre-Connect Lifecycle Hook

**Current behavior**: `onHopConnected` fires **after** each hop connects.

**Issue**: Pomerium must start **before** the first SSH connection. Users must manage this externally:

```typescript
// Current workaround - external management
await pomeriumController.start();  // BEFORE
const orchestrator = new SSHOrchestrator({...});
await orchestrator.connect();
```

**Desired behavior**: Library handles pre-connect setup via hook.

---

### Problem 2: No Connection State Visibility

**Current behavior**: No way to check if connected. Users must track manually:

```typescript
// Current workaround - manual tracking
if (!this.orchestrator) throw new Error("Not connected");
return this.orchestrator.execRemote(cmd);
```

**Issue**: Every method needs this guard. No visibility into reconnecting state.

---

### Problem 3: Repeated Credentials Across Hops

**Current behavior**: Full config required for each hop:

```typescript
// Current - repetitive
hops: [
  { name: "jump", host: "...", username: "user", password: "pass", readyTimeout: 60000 },
  { name: "remote", host: "...", username: "user", password: "pass", readyTimeout: 60000 },
]
```

**Issue**: DRY violation when credentials are same across hops.

---

### Problem 4: No Disconnect Lifecycle Hook

**Current behavior**: No way to run cleanup before disconnect.

**Issue**: Cannot run cleanup scripts (e.g., logout commands) before connection closes.

---

### Problem 5: Fire-and-Forget Reconnection

**Current behavior**: Reconnection attempts run async without feedback:

```typescript
// Current - fire and forget
private handleDisconnection(hopName: string): void {
  this.connect().catch((err) => {
    this.logger.error(`Failed to re-establish: ${err.message}`);
  });
}
```

**Issues**:
- No operation queuing during reconnection
- No exponential backoff
- No max retry limit
- Operations fail immediately if called during reconnection

---

### Problem 6: No Health Monitoring

**Current behavior**: Stale connections detected only when operations fail.

**Issue**: For long-lived services, proactive health checks are essential to detect and recover from stale connections before they impact requests.

---

### Problem 7: No Connection Pooling

**Current behavior**: Single connection per orchestrator instance.

**Issue**: Backend services handling concurrent requests need connection pooling with acquire/release semantics.

---

## Implementation Plan

### v1.1.0 - Essential Improvements

**Release Goal**: Enable seamless  migration

#### Features

| Feature | Description |
|---------|-------------|
| `onBeforeConnect` hook | Callback fired before connection chain starts |
| `onBeforeDisconnect` hook | Callback fired before disconnect |
| `defaults` config | Shared credentials merged into each hop |
| `isConnected` property | Simple boolean connection state check |
| `port` optional | Default to 22 if not specified |

#### Type Changes (`src/types/index.ts`)

```typescript
// NEW: Defaults that apply to all hops
export interface SSHDefaults {
  port?: number;
  username?: string;
  password?: string;
  privateKey?: string | Buffer;
  readyTimeout?: number;
}

// UPDATED: OrchestratorConfig
export interface OrchestratorConfig {
  hops: SSHConfig[];
  defaults?: SSHDefaults;           // NEW
  logger?: LoggerInterface;
  onBeforeConnect?: () => Promise<void>;   // NEW
  onHopConnected?: (hopIndex: number, config: SSHConfig) => Promise<void>;
  onBeforeDisconnect?: () => Promise<void>; // NEW
}

// UPDATED: SSHConfig - port now optional
export interface SSHConfig {
  name: string;
  host: string;
  port?: number;  // Was required, now optional (defaults to 22)
  username?: string;
  password?: string;
  privateKey?: string | Buffer;
  readyTimeout?: number;
}
```

#### SSHOrchestrator Changes (`src/core/SSHOrchestrator.ts`)

```typescript
// NEW: Connection state property
public get isConnected(): boolean {
  return this.tunnels.length === this.config.hops.length;
}

// NEW: Credential resolution
private resolveCredentials(hop: SSHConfig): SSHConfig {
  return {
    port: 22,  // Default
    ...this.config.defaults,
    ...hop,    // Hop config overrides defaults
  };
}

// UPDATED: connect() with pre-hook
public async connect(): Promise<void> {
  if (this.config.onBeforeConnect) {
    await this.config.onBeforeConnect();
  }
  // ... existing connection logic, using resolveCredentials() ...
}

// UPDATED: disconnect() with pre-hook
public async disconnect(): Promise<void> {
  if (this.config.onBeforeDisconnect) {
    await this.config.onBeforeDisconnect();
  }
  // ... existing disconnect logic ...
}
```

#### Usage After v1.1.0

```typescript
const orchestrator = new SSHOrchestrator({
  defaults: { username: "user", password: "pass", readyTimeout: 60000 },
  hops: [
    { name: "jump", host: "127.0.0.1", port: 2222 },
    { name: "remote", host: "10.0.1.100" },  // port defaults to 22
  ],
  onBeforeConnect: async () => await pomerium.start(),
  onBeforeDisconnect: async () => pomerium.stop(),
});

// Direct usage - no wrapper needed
await orchestrator.connect();
await orchestrator.execRemote("kubectl get pods");
await orchestrator.disconnect();
```

---

### v1.2.0 - Robustness

**Release Goal**: Production-ready for long-lived services

#### Features

| Feature | Description |
|---------|-------------|
| `credentialProvider` | Async function for dynamic credential resolution |
| `ConnectionState` enum | Full state visibility: disconnected, connecting, connected, reconnecting |
| `onStateChange` callback | Notification on state transitions |
| Reconnection queue | Queue operations during reconnect, retry with exponential backoff |
| Health check | Periodic ping to detect stale connections |

#### Type Changes (`src/types/index.ts`)

```typescript
// NEW: Dynamic credential provider
export type CredentialProvider = (hopName: string) => Promise<{
  username?: string;
  password?: string;
  privateKey?: string | Buffer;
}>;

// NEW: Connection state
export type ConnectionState =
  | 'disconnected'
  | 'connecting'
  | 'connected'
  | 'reconnecting'
  | 'disconnecting';

// NEW: Reconnection options
export interface ReconnectionOptions {
  enabled?: boolean;           // default: true
  maxRetries?: number;         // default: 5
  initialDelay?: number;       // default: 1000ms
  maxDelay?: number;           // default: 30000ms
  backoffMultiplier?: number;  // default: 2
  queueOperations?: boolean;   // default: true
}

// NEW: Health check options
export interface HealthCheckOptions {
  enabled?: boolean;           // default: false
  interval?: number;           // default: 30000ms
  command?: string;            // default: 'echo 1'
  timeout?: number;            // default: 5000ms
}

// UPDATED: OrchestratorConfig
export interface OrchestratorConfig {
  // ... v1.1 fields ...
  credentialProvider?: CredentialProvider;  // NEW
  onStateChange?: (state: ConnectionState, prev: ConnectionState) => void;  // NEW
  reconnection?: ReconnectionOptions;  // NEW
  healthCheck?: HealthCheckOptions;    // NEW
}
```

#### SSHOrchestrator Changes (`src/core/SSHOrchestrator.ts`)

```typescript
// NEW: State management
private _state: ConnectionState = 'disconnected';
public get state(): ConnectionState { return this._state; }

private setState(newState: ConnectionState): void {
  const prev = this._state;
  this._state = newState;
  this.config.onStateChange?.(newState, prev);
}

// NEW: Operation queue for reconnection
private operationQueue: Array<{
  operation: () => Promise<any>;
  resolve: (value: any) => void;
  reject: (error: any) => void;
}> = [];

// UPDATED: Credential resolution with async provider
private async resolveCredentials(hop: SSHConfig): Promise<SSHConfig> {
  const merged = { port: 22, ...this.config.defaults, ...hop };
  if (this.config.credentialProvider) {
    const dynamic = await this.config.credentialProvider(hop.name);
    return { ...merged, ...dynamic };
  }
  return merged;
}

// NEW: Reconnection with exponential backoff
private async handleDisconnection(hopName: string): Promise<void> {
  if (!this.config.reconnection?.enabled) return;
  this.setState('reconnecting');

  let attempt = 0;
  let delay = this.config.reconnection.initialDelay ?? 1000;
  const maxRetries = this.config.reconnection.maxRetries ?? 5;

  while (attempt < maxRetries) {
    try {
      await this.reconnect();
      this.setState('connected');
      await this.flushQueue();
      return;
    } catch {
      attempt++;
      await this.sleep(delay);
      delay = Math.min(delay * 2, this.config.reconnection.maxDelay ?? 30000);
    }
  }

  this.setState('disconnected');
  this.rejectQueue(new Error('Reconnection failed'));
}

// NEW: Health check
private healthCheckTimer?: NodeJS.Timeout;

private startHealthCheck(): void {
  if (!this.config.healthCheck?.enabled) return;
  const interval = this.config.healthCheck.interval ?? 30000;

  this.healthCheckTimer = setInterval(async () => {
    try {
      await Promise.race([
        this.execRemote(this.config.healthCheck?.command ?? 'echo 1'),
        this.timeout(this.config.healthCheck?.timeout ?? 5000),
      ]);
    } catch {
      this.handleDisconnection('health-check');
    }
  }, interval);
}
```

#### Usage After v1.2.0

```typescript
const orchestrator = new SSHOrchestrator({
  defaults: { username: "user" },
  credentialProvider: async (hopName) => ({
    password: await vault.getSecret(`ssh/${hopName}`),
  }),
  hops: [...],
  reconnection: {
    enabled: true,
    maxRetries: 10,
    queueOperations: true,
  },
  healthCheck: {
    enabled: true,
    interval: 60000,
  },
  onStateChange: (state, prev) => {
    console.log(`Connection: ${prev} → ${state}`);
  },
});
```

---

### v2.0.0 - Connection Pool

**Release Goal**: High-throughput backend service support

#### Features

| Feature | Description |
|---------|-------------|
| `SSHConnectionPool` class | Pool manager with acquire/release |
| Shared Pomerium | Single tunnel, multiple SSH connections |
| Pool lifecycle | initialize(), drain(), stats |
| Idle cleanup | Auto-close unused connections after timeout |

#### Architecture: Shared Pomerium

```
┌─────────────────────────────────────────────────────┐
│  SSHConnectionPool                                  │
│  ┌─────────────────────────────────────────────┐   │
│  │  Shared Pomerium Tunnel (onBeforeConnect)   │   │
│  │  localhost:2222 ──────► Jump Server         │   │
│  └─────────────────────────────────────────────┘   │
│       │           │           │           │        │
│  ┌────▼───┐  ┌────▼───┐  ┌────▼───┐  ┌────▼───┐   │
│  │ Conn 1 │  │ Conn 2 │  │ Conn 3 │  │ Conn N │   │
│  │ Remote │  │ Remote │  │ Remote │  │ Remote │   │
│  └────────┘  └────────┘  └────────┘  └────────┘   │
└─────────────────────────────────────────────────────┘
```

#### New File: `src/core/SSHConnectionPool.ts`

```typescript
export interface PoolConfig {
  orchestratorConfig: OrchestratorConfig;
  minConnections?: number;  // default: 1
  maxConnections?: number;  // default: 5
  acquireTimeout?: number;  // default: 30000ms
  idleTimeout?: number;     // default: 300000ms (5 min)
}

export class SSHConnectionPool {
  private available: SSHOrchestrator[] = [];
  private inUse: Set<SSHOrchestrator> = new Set();
  private pomeriumStarted: boolean = false;

  constructor(private config: PoolConfig) {}

  async initialize(): Promise<void> {
    // Start shared Pomerium once
    if (this.config.orchestratorConfig.onBeforeConnect) {
      await this.config.orchestratorConfig.onBeforeConnect();
      this.pomeriumStarted = true;
    }

    // Create minimum connections (skip onBeforeConnect for each)
    const min = this.config.minConnections ?? 1;
    for (let i = 0; i < min; i++) {
      const conn = await this.createConnection();
      this.available.push(conn);
    }
  }

  async acquire(): Promise<SSHOrchestrator> {
    if (this.available.length > 0) {
      const conn = this.available.pop()!;
      this.inUse.add(conn);
      return conn;
    }

    if (this.inUse.size < (this.config.maxConnections ?? 5)) {
      const conn = await this.createConnection();
      this.inUse.add(conn);
      return conn;
    }

    return this.waitForConnection();
  }

  release(conn: SSHOrchestrator): void {
    this.inUse.delete(conn);
    this.available.push(conn);
    this.scheduleIdleCleanup(conn);
  }

  async drain(): Promise<void> {
    for (const conn of [...this.available, ...this.inUse]) {
      await conn.disconnect();
    }
    // Stop shared Pomerium
    if (this.config.orchestratorConfig.onBeforeDisconnect) {
      await this.config.orchestratorConfig.onBeforeDisconnect();
    }
  }

  private async createConnection(): Promise<SSHOrchestrator> {
    // Create orchestrator WITHOUT onBeforeConnect (Pomerium already started)
    const configWithoutPreHook = {
      ...this.config.orchestratorConfig,
      onBeforeConnect: undefined,  // Skip - already done in initialize()
    };
    const conn = new SSHOrchestrator(configWithoutPreHook);
    await conn.connect();
    return conn;
  }
}
```

#### Usage After v2.0.0

```typescript
// Initialize pool
const pool = new SSHConnectionPool({
  orchestratorConfig: {
    defaults: { username: 'user', password: 'pass' },
    hops: [
      { name: "jump", host: "127.0.0.1", port: 2222 },
      { name: "remote", host: "10.0.1.100" },
    ],
    onBeforeConnect: async () => await pomerium.start(),
    onBeforeDisconnect: async () => pomerium.stop(),
  },
  minConnections: 2,
  maxConnections: 10,
  idleTimeout: 300000,
});

await pool.initialize();

// Handle requests
app.post('/api/execute', async (req, res) => {
  const conn = await pool.acquire();
  try {
    const result = await conn.execRemote(req.body.command);
    res.json({ result });
  } finally {
    pool.release(conn);
  }
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  await pool.drain();
  process.exit(0);
});
```

---

## File Change Summary

| Version | File | Action |
|---------|------|--------|
| v1.1.0 | `src/types/index.ts` | Add `SSHDefaults`, update configs |
| v1.1.0 | `src/core/SSHOrchestrator.ts` | Add hooks, defaults, isConnected |
| v1.1.0 | `examples/-migration/*` | Update to use new features |
| v1.2.0 | `src/types/index.ts` | Add state, reconnection, health types |
| v1.2.0 | `src/core/SSHOrchestrator.ts` | Add state, queue, health check |
| v2.0.0 | `src/core/SSHConnectionPool.ts` | **NEW** - Pool manager |
| v2.0.0 | `src/index.ts` | Export `SSHConnectionPool` |
| v2.0.0 | `examples/long-lived-service/*` | **NEW** - Pool usage example |

---

## v1.1.0 Implementation Evaluation

**Date**: 2025-12-28
**Status**: ✅ Implemented and tested

### Problem Resolution Summary

| Problem | Status | Implementation |
|---------|--------|----------------|
| **1. No Pre-Connect Hook** | ✅ Solved | `onBeforeConnect` in `OrchestratorConfig` |
| **2. No Connection State** | ✅ Solved | `isConnected` getter property |
| **3. Repeated Credentials** | ✅ Solved | `defaults` config with merge logic |
| **4. No Disconnect Hook** | ✅ Solved | `onBeforeDisconnect` in `OrchestratorConfig` |
| **5. Fire-and-Forget Reconnection** | ⏳ Pending | Planned for v1.2.0 |
| **6. No Health Monitoring** | ⏳ Pending | Planned for v1.2.0 |
| **7. No Connection Pooling** | ⏳ Pending | Planned for v2.0.0 |

### Evidence in Migration Example

The updated [`examples/-migration/Remote.ts`](../examples/-migration/Remote.ts) demonstrates all v1.1 features:

```typescript
// Problem 1: Solved - onBeforeConnect for Pomerium
onBeforeConnect: async () => {
  console.log("Starting Pomerium tunnel...");
},

// Problem 2: Solved - isConnected property
get isConnected(): boolean {
  return this.orchestrator.isConnected;
}

// Problem 3: Solved - defaults config (no more repetition)
defaults: {
  username: config.username,
  password: config.password,
  readyTimeout: 60000,
},
hops: [
  { name: "jump", host: "127.0.0.1", port: config.pomeriumPort },
  { name: "remote", host: config.remoteHost },  // port defaults to 22
],

// Problem 4: Solved - onBeforeDisconnect for cleanup
onBeforeDisconnect: async () => {
  console.log("Stopping Pomerium tunnel...");
},
```

### Code Reduction Analysis

| Metric | Before () | After (v1.1) | Reduction |
|--------|------------------------|--------------|-----------|
| Remote.ts lines | ~469 | ~80 | **83%** |
| SFTP.ts lines | ~159 | 0 (use SFTPClient) | **100%** |
| Manual state tracking | Required | Not needed | **Eliminated** |
| Credential duplication | Per-hop | Single `defaults` | **Eliminated** |

### Is the Wrapper Class Still Needed?

**Observation**: The `Remote` class in the migration example is now mostly pass-through:

```typescript
async connect() { await this.orchestrator.connect(); }
async disconnect() { await this.orchestrator.disconnect(); }
get isConnected() { return this.orchestrator.isConnected; }
async execRemote(cmd) { return this.orchestrator.execRemote(cmd); }
```

**Verdict**: The wrapper is **optional** for simple use cases. Users can now use `SSHOrchestrator` directly:

```typescript
// Direct usage - no wrapper needed for one-shot scripts
const orchestrator = new SSHOrchestrator({
  defaults: { username, password },
  hops: [...],
  onBeforeConnect: () => pomerium.start(),
  onBeforeDisconnect: () => pomerium.stop(),
});

await orchestrator.connect();
await orchestrator.execRemote("kubectl get pods");
await orchestrator.disconnect();
```

**When to keep a wrapper**:
- Domain-specific logic (e.g., `ensureSSHKeySetup()` combining multiple operations)
- API naming preferences (e.g., `getJumpSftp()` vs `getJumpSFTP()`)
- Integration with other services (e.g., Robin setup in `onHopConnected`)

### Remaining Work for Long-Lived Services

For **production backend services**, the following features from v1.2/v2.0 are essential:

| Feature | Importance | Use Case |
|---------|------------|----------|
| Reconnection queue | **Critical** | Prevent operation failures during transient disconnects |
| Health checks | **Important** | Proactive stale connection detection |
| Connection pool | **Critical** | Handle concurrent requests without blocking |
| Credential provider | **Nice to have** | Dynamic secrets from Vault/AWS Secrets Manager |

### Conclusion

**v1.1.0 successfully enables the  migration** by solving the immediate pain points (Problems 1-4). The library is now suitable for one-shot automation scripts.

**For production backend services**, v1.2.0 (robustness) and v2.0.0 (pooling) are required before deployment.

---

## Backwards Compatibility

- All v1.x changes are **additive** (new optional config fields)
- Existing code continues to work without changes
- v2.0 is also backwards compatible (pool is opt-in)
- `SimplifiedConfig` remains supported for legacy 2-hop usage
